#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <conio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include "my_func.h"
#define SIZE 256

FILE *getNameFile(char *name_file, char *mode, char *text)
{
	FILE *fp;
	int err;

	do
	{
		printf("Въведете име на файла %s: ", text);
		err = scanf("%s", name_file);
	} while (err != 1);

	if ((fp = fopen(name_file, mode)) == NULL)
	{
		printf("\nФайлът <%s> Не може да се отвори - error No % d !!!\n", name_file, errno);
		printf("ГРЕШКА No %d %s", errno, strerror(errno));
		system("pause");
	}
	else
	{
		printf("\nФайлът <%s> е отворен успешно за обработка !\n\n", name_file);
		system("pause");
	}
	return fp;
}

void printTextFile()
{
	FILE *fp = NULL;
	int fileName[SIZE], ch;
	if ((fp = getNameFile(fileName, "rb", "за четене")) != NULL)
	{
		while (1)
		{
			ch = fgetc(fp);//чете символ по символ
			if (ch == EOF)//докато не стигне край на файла
				break;

			fputc(ch, stdout);//принтира на екрана символа
		}
	}
	system("pause");
	fclose(fp);
}

void countSymbols(FILE *fp_in, FILE *fp_out)
{
	short asciiTable[SIZE] = { 0 }; //нулираме масива
	short c = 0;//защото е от 2 байта
	rewind(fp_in);

	while (1)
	{
		c = fgetc(fp_in);//четем символ

		if (feof(fp_in))//докато не стигнем EOF 
			break;

		asciiTable[c]++;
	}

	printf("СИМВОЛ|ASCII-DEC|ASCII-HEX|BROI\n");
	fprintf(fp_out, "СИМВОЛ|ASCII-DEC|ASCII-HEX|BROI\n");

	for (int k = 0; k < 256; k++)
	{
		if (asciiTable[k] > 0)//ако не се среща даден символ не го принтира		
		{
			printf("%c\t%u\t%x\t%d\n", k, k, k, asciiTable[k]);
			fprintf(fp_out, "%c\t%u\t%x\t%d\n", k, k, k, asciiTable[k]);
		}
	}
}

void countChosenSymbol(FILE *fp_in)
{
	short count = 0;
	int allSymbols = 0;
	int ch;
	int c;
	float ratio;
	rewind(fp_in);// връщаме файловия пойнтер в началото на файла

	printf("Въведете символ за преброяване:");
	scanf("%c", &ch);
	ch = getchar();

	while (1)
	{
		c = fgetc(fp_in);

		if (c == EOF) //четем символ по символ докато не стигнем край на файла
			break;

		if (c == ch) // ако има съвпадение увеличаваме брояча
		{
			count++;
		}
		allSymbols++;
	}
	ratio = (float)count / allSymbols; // изчисляваме отношението

	printf("\nОбщ брой символи: %d\n Брой на срещане на символ \'%c\' във входния файл е = %d пъти \n%0.3f%% спрямо общия брой\n\n",
		allSymbols, ch, count, ratio);
}

void changeSymbol(FILE *fp_in, FILE *fp_out)
{
	char ch1, ch2;
	short c;
	rewind(fp_in);

	printf("\nВъведете символ за замяна:");
	scanf("%c", &ch1);
	ch1 = _getche();

	printf("\nЗамени с:");
	ch2 = getchar();

	while (1)
	{
		c = fgetc(fp_in);

		if (c == EOF)
			break;

		if (c == ch1)
		{
			fputc(ch2, fp_out); // ако има съвпадение заменяме със символа който сме избрали и го запаметяваме в fp_out
		}
		else
		{
			fputc(c, fp_out);// ако няма съвпадение си записваме сегашния символ в изходния файл
		}
	}
	printf("\nИнформацията е запазена\n");
	system("pause");
}

void maxMinNumbers(FILE *fp_in)
{
	char number[SIZE], *reminder;
	long int num = 0;
	int min = INT_MAX, max = INT_MIN;
	int isEmpty = 0; // флаг в случай, че файлът е празен(няма чилса)
	errno = 0;
	rewind(fp_in);

	while (fscanf(fp_in, "%s", &number) != EOF) // докато има прочетен ред 
	{
		num = strtol(number, &reminder, 10); // в Num присвояваме резултата от функцията strtol
		if (reminder[0] != '\0') // проверяваме дали прочетения ред има символи (123а /аа125)
		{
			printf("\nФайлът не може да бъде обработен\n");
			system("pause");
			return;
		}
		else if (errno == ERANGE) // ако подадем прекалено голямо число на входа ни излиза съобщение за препълване
		{
			printf("\n!!Препълване на входа!!\n");
			system("pause");
			return;
		}
		else
		{
			if (min > num) // проверяваме дали min е по-малко от прочетеното число във файла
			{
				min = num; // ако е записваме стойноста му в min
				isEmpty = 1; // вдигаме флага в случай, че има прочетено число
			}
			if (max < num) // проверяваме дали max е по-голямо от прочетеното число във файла
			{
				max = num;
				isEmpty = 1;
			}
		}
	}

	if (isEmpty == 1) // ако има прочетени числа 
		printf("\nМаксимална стойност: %d\nМинимална стойност: %d\n", max, min);

	else
		printf("\nФайлът не съдържа числа\n");
}

void writeNumbersOfInterval(FILE *fp_in, FILE *fp_out)
{
	char number[SIZE], *reminder;
	int lower, upper; // променливи за долно и горна граница
	unsigned int col;
	long int num = 0;
	int n = 0;
	rewind(fp_in);

	printf("Въведете долна граница=");
	scanf("%d", &lower);
	do
	{
		printf("Въведете горна граница=");
		scanf("%d", &upper);
	} while (lower >= upper);

	printf("Въведете брой колони=");
	scanf("%d", &col);

	while (fscanf(fp_in, "%s", &number) != EOF)
	{
		num = strtol(number, &reminder, 10); // в Num присвояваме резултата от функцията strtol
		if (reminder[0] != '\0') // проверяваме дали прочетения ред има символи (123а /аа125)
		{
			printf("\nФайлът не може да бъде обработен\n");
			system("pause");
			return;
		}
		else
		{
			if (num >= lower && num <= upper) // проверяме дали числото се намира в интервала 
			{
				if (n < col)
				{
					fprintf(fp_out, "%d\t", num); //докато N е по-малко от колоните записваме числата с 1 таб разтояние
					n++;
				}
				else
				{
					fprintf(fp_out, "\n%d\t", num); // когато N стане по-голямо от колоните записваме чилота на нов ред с 1 таб разтояние
					n = 1; // ресетваме n
				}
			}
		}
	}
}

void averageOfNumbers(FILE *fp_in)
{
	char number[SIZE], *reminder;
	long int num, count = 0, sum = 0;
	float average = 0;
	errno = 0;
	rewind(fp_in);

	while (fscanf(fp_in, "%s", &number) != EOF) // докато има прочетен ред 
	{
		num = strtol(number, &reminder, 10); // в Num присвояваме резултата от функцията strtol
		if (reminder[0] != '\0') // проверяваме дали прочетения ред има символи (123а /аа125)
		{
			printf("\nФайлът не може да бъде обработен\n");
			system("pause");
			return;
		}
		else if (errno == ERANGE) // ако подадем прекалено голямо число на входа ни излиза съобщение за препълване
		{
			printf("\n!!Препълване на входа!!\n");
			system("pause");
			return;
		}
		else
		{
			int max = INT_MAX - num;
			int min = INT_MIN - num;
			if (num >= 0 && (max <= num) || num <= 0 && (min > num)) // проверка за препълване
			{
				printf("\n!!Препълване при събиране!!\n");
				system("pause");
				exit(0);
			}
			if (num > 0)
			{
				sum += num;
				count++;
			}
		}
	}
	if (count > 0)
	{
		average = (float)sum / count;
		printf("Средно аритметичното е = %f\n", average);
		return;
	}
	else
	{
		printf("\nФайлът не съдържа числа\n");
		return 0;
	}
}

void changeNegativeNumbers(FILE *fp_in, FILE *fp_out)
{
	char number[SIZE], *reminder;
	long int num = 0;
	rewind(fp_in);

	while (fscanf(fp_in, "%s", &number) != EOF) // докато има прочетен ред 
	{
		num = strtol(number, &reminder, 10); // в Num присвояваме резултата от функцията strtol
		if (reminder[0] != '\0') // проверяваме дали прочетения ред има символи (123а /аа125)
		{
			printf("\nФайлът не може да бъде обработен\n");
			system("pause");
			return; // връща в главната функция
		}
		else
		{
			if (num < 0) // проверка за отрицателно число
			{
				num = 0; // нулираме прочетеното число 
				fprintf(fp_out, "%d%c", num, ' '); // и го записваме в изходния файл
			}
			else
			{
				fprintf(fp_out, "%d%c", num, ' '); //ако числото не е отрицателно го записваме в изходния файл
			}
		}
	}
	printf("\nИнформацията е запазена\n");
}

