#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <conio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include "my_func.h"

FILE *getNameFile(char *name_file, char *mode, char *text)
{
	FILE *fp;
	int err;

	do
	{
		printf("\nВъведете име на файла %s:", text);
		err = scanf("%s", name_file);
	} while (err != 1);

	if ((fp = fopen(name_file, mode)) == NULL)
	{
		printf("\nФайлът <%s> Не може да се отвори - error No % d !!!\n", name_file, errno);
		printf("ГРЕШКА No %d %s", errno, strerror(errno));
		system("pause");
	}
	else
	{
		printf("\nФайлът <%s> е отворен успешно за обработка !\n\n", name_file);
		system("pause");
	}
	return fp;
}

void printTextFile()
{
	FILE *fp = NULL;
	char fileName[256], ch;
	if ((fp = getNameFile(fileName, "rt", "за четене")) != NULL)
	{
		while (1)
		{
			ch = fgetc(fp);
			if (ch == EOF)
				break;
			fputc(ch, stdout);
		}
	}
	system("pause");
	fclose(fp);
}

void countSymbols(FILE *fp_in, FILE *fp_out) 
{
	short asciiTable[256] = { 0 }; //нулираме масива
	short c = 0;
	rewind(fp_in);

	while (1)
	{
		c = fgetc(fp_in);//четем символ

		if (c == EOF)//докато не стигнем EOF
			break;

		asciiTable[c]++;
	}

	printf("\nСИМВОЛ|ASCII-DEC|ASCII-HEX|BROI\n");
	fprintf(fp_out, "\nСИМВОЛ|ASCII-DEC|ASCII-HEX|BROI\n");

	for (size_t k = 0; k < 256; k++)
	{
		if (asciiTable[k] > 0)
		{
			printf("%c\t%u\t%x\t%d\n", k, k, k, asciiTable[k]);
			fprintf(fp_out, "%c\t%u\t%x\t%d\n", k, k, k, asciiTable[k]);
		}
	}
}

void countChosenSymbol(FILE *fp_in)
{
	short count = 0;
	int allSymbols = 0;
	char c, ch;
	float ratio;
	rewind(fp_in);// връщаме файловия пойнтер в началото на файла

	printf("Въведете символ за преброяване:");
	scanf("%c", &ch);
	ch = _getche();

	while (1)
	{
		c = fgetc(fp_in);

		if (c == EOF) //четем символ по символ докато не стигнем край на файла
			break;

		if (c == ch) // ако има съвпадение увеличаваме брояча
		{
			count++;
		}
		allSymbols++;
	}
	ratio =(float)count / allSymbols; // изчисляваме отношението

	printf("\nОбщ брой символи: %d\n Брой на срещане на символ \'%c\' във входния файл е = %d пъти \n%0.2f%% спрямо общия брой\n\n", 
		allSymbols, ch, count, ratio);
}

void changeSymbol(FILE *fp_in, FILE *fp_out) 
{
	char ch1, ch2, c;
	rewind(fp_in);

	printf("\nВъведете символ за замяна:");
	scanf("%c", &ch1);
	ch1 = _getche();

	printf("\nЗамени с:");
	ch2 = getchar();

	while (1)
	{
		c = fgetc(fp_in);

		if (c == EOF) 
			break; 

		if (c == ch1) 
		{
			fputc(ch2, fp_out); // ако има съвпадение заменяме със символа който сме избрали и го запаметяваме в fp_out
		}
		else
		{
			fputc(c, fp_out);// ако няма съвпадение си записваме сегашния символ в изходния файл
		}
	}
}

void maxMinNumbers(FILE *fp_in) 
{
	int num = 0;
	int min = INT_MAX, max = INT_MIN;
	int flag = 0; // флаг в случай, че файлът е празен(няма чилса)
	rewind(fp_in);

	while (fscanf(fp_in, "%d", &num) != EOF)
	{
		if (min > num) // проверяваме дали min е по-малко от прочетеното число във файла
		{
			min = num; // ако е записваме стойноста му в min
			flag = 1; // вдигаме флага в случай, че има прочетено число
		}
		if (max < num) // проверяваме дали max е по-голямо от прочетеното число във файла
		{
			max = num; 
			flag = 1;
		}
	}

	if (flag == 1) // ако има прочетени числа 
		printf("\nМаксимална стойност: %d\nМинимална стойност: %d\n", max, min);

	else
		printf("\n Няма прочетени числа във файлът \n");
}

void writeNumbersOfInterval(FILE *fp_in, FILE *fp_out) 
{
	int lower, upper; // променливи за долно и горна граница
	unsigned int col;
	int num = 0, n = 0;
	rewind(fp_in);

	printf("Въведете долна граница=");
	scanf("%d", &lower);
	do
	{
		printf("Въведете горна граница=");
		scanf("%d", &upper);
	} while (lower >= upper);

	printf("Въведете брой колони=");
	scanf("%d", &col);

	while (fscanf(fp_in, "%d", &num) != EOF)
	{
		if (num >= lower && num <= upper) // проверяме дали числото се намира в интервала 
		{
			if (n < col) 
			{
				fprintf(fp_out, "%d\t", num); //докато N е по-малко от колоните записваме числата с 1 таб разтояние
				n++; 
			}
			else
			{
				fprintf(fp_out, "\n%d\t", num); // когато N стане по-голямо от колоните записваме чилота на нов ред с 1 таб разтояние
				n = 1; // ресетваме N
			}
		}
	}
}

float averageOfNumbers(FILE *fp_in) 
{
	char number[256], *reminder;
	long int num, count = 0, sum = 0;
	float average = 0;
	errno = 0; 
	rewind(fp_in);

	while (fscanf(fp_in, "%s", &number) != EOF) // докато има прочетен ред 
	{
		num = strtol(number, &reminder, 10); // в Num присвояваме резултата от функцията strtol
		if (reminder[0] != '\0') // проверяваме дали прочетения ред има цифри и символи, ако има дава грешка: (123а /аа125)
		{
			printf("\nFormat exception\n");
			system("pause");
			exit(0); // изход
		}
		else if (errno == ERANGE) // ако подадем прекалено голямо число на входа ни излиза съобщение за препълване
		{
			printf("\n!!Препълване на входа!!\n");
			system("pause");
			exit(0);
		}
		else
		{
			int max = INT_MAX - num;
			int min = INT_MIN - num;
			if (num >= 0 && (max <= num) || num <= 0 && (min > num)) // проверка за препълване
			{
				printf("\n!!Препълване при събиране!!\n");
				system("pause");
				exit(0);
			}
			if (num > 0)
			{
				sum += num;
				count++;
			}
		}
	}

	average = (float)sum / count;
	return average;
}

void changeNegativeNumbers(FILE *fp_in, FILE *fp_out)
{
	int num = 0;
	rewind(fp_in);

	while (fscanf(fp_in, "%d", &num) != EOF)
	{
		if (num < 0) // проверка за отрицателно число
		{
			num = 0; // нулираме прочетеното число 
			fprintf(fp_out, "%d%c", num, ' '); // и го записваме в изходния файл
		}
		else
		{
			fprintf(fp_out, "%d%c", num, ' '); //ако числото не е отрицателно го записваме в изходния файл
		}
	}
	printf("\nИнформацията е запазена\n");
}
